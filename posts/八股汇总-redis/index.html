<!DOCTYPE html>
<html lang="zh_CN"><head>
    <meta charset="utf-8"><title>[八股汇总] redis&nbsp;-&nbsp;XUN</title>

    <meta name="theme-color" content="#e0e0e0">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="msapplication-navbutton-color" content="#e0e0e0">
    <meta name="apple-mobile-web-app-status-bar-style" content="#e0e0e0">
    
    
    <link rel="icon" type="image/png" href="/HQL.ico">
    
    
    
     
    
    <link rel="stylesheet" href="https://cenjianxun.github.io/scss/main.min.ec2829703735eaa7170982f2fe9f19ceb03c1fb0e4ce9a557734b4a0f30ea39b.css">
    
    
    <script type="text/javascript" src="/js/main.js" defer></script>
</head><body class="mytheme">
  <div class="body-container">
    <aside>
    <div class="nav-title">
        <a href="/" class="home-link" target="_blank">XUN</a>
    </div>
    <section class="sidebar">
        <div id="sidebar-info" class="sidebar-info">
            <div class="sidebar-about">
                <p class="lead">
                    想写一个播放器想写一个传输工具想写一个通讯工具想在高速公路上自由coding一边听歌如果一个古代人技能点是写代码怎么办
                </p>
            </div>
            <div class="count">文章</div>
            <div class="social">
                <a href="https://github.com/cenjianxun" target="_blank" rel="noopener noreferrer">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github">
                        <path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/>
                        <path d="M9 18c-4.51 2-5-2-7-2"/> 
                        </svg>
                </a>
                <a href="" target="_blank" rel="noopener noreferrer">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor"  stroke-linecap="round" stroke-linejoin="round"
                        class="lucide lucide-twitter">
                        <path
                            d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z">
                        </path>
                    </svg>
                </a>
                <a href=""  target="_blank" rel="noopener noreferrer">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                        class="lucide lucide-mail">
                        <rect width="20" height="16" x="2" y="4" rx="2"></rect>
                        <path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path>
                    </svg>
                </a>
                <a href=""  target="_blank" rel="noopener noreferrer">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                        class="lucide lucide-rss">
                        <path d="M4 11a9 9 0 0 1 9 9"></path>
                        <path d="M4 4a16 16 0 0 1 16 16"></path>
                        <circle cx="5" cy="19" r="1"></circle>
                    </svg>
                </a>
            </div>
        </div>
        
        
            

<div id="sidebar-toc" class="sidebar-toc">
    
    <header>
        <span class="toc-bar"></span>
        <h4 class="toc-header">[八股汇总] redis</h4>
        <span class="toc-bar"></span>
    </header>
    
    <nav id="TableOfContents">
  <ul>
    <li><a href="#性能--performance">性能 ｜ performance</a></li>
    <li><a href="#和-memcached-比较">和 Memcached 比较</a></li>
    <li><a href="#为什么作为mysql缓存">为什么作为mysql缓存：</a></li>
    <li><a href="#数据类型及数据结构">数据类型及数据结构</a>
      <ul>
        <li><a href="#数据类型--type">数据类型 ｜ TYPE</a></li>
        <li><a href="#数据结构--structure">数据结构 ｜ STRUCTURE：</a></li>
        <li><a href="#数据类型和数据结构的关系">数据类型和数据结构的关系</a></li>
      </ul>
    </li>
    <li><a href="#redis-是单线程吗">redis 是单线程吗</a></li>
    <li><a href="#持久化">持久化</a>
      <ul>
        <li><a href="#aof-日志过大会触发什么机制">AOF 日志过大，会触发什么机制？</a></li>
        <li><a href="#rdb实现">RDB实现：</a></li>
      </ul>
    </li>
    <li><a href="#主从-哨兵-集群">主从 哨兵 集群</a>
      <ul>
        <li><a href="#主从-master-slaver">主从 master-slaver</a></li>
        <li><a href="#哨兵-sentinel">哨兵 sentinel：</a></li>
        <li><a href="#集群-cluster">集群 cluster：</a></li>
      </ul>
    </li>
    <li><a href="#过期删除和内存淘汰">过期删除和内存淘汰</a>
      <ul>
        <li><a href="#expire-policy">Expire policy</a></li>
        <li><a href="#内存淘汰">内存淘汰</a></li>
        <li><a href="#持久化时对过期键会如何处理">持久化时，对过期键会如何处理？</a></li>
        <li><a href="#主从模式中对过期键会如何处理">主从模式中，对过期键会如何处理</a></li>
      </ul>
    </li>
    <li><a href="#缓存雪崩热点失效缓存穿透">缓存雪崩、热点失效、缓存穿透</a>
      <ul>
        <li><a href="#缓存穿透--cache-penetration">缓存穿透 ｜ cache penetration</a></li>
        <li><a href="#热点失效--hotspot-invalid">热点失效 ｜ hotspot invalid</a></li>
        <li><a href="#缓存雪崩--cache-avalanche">缓存雪崩 ｜ cache avalanche</a></li>
      </ul>
    </li>
    <li><a href="#缓存更新策略">缓存更新策略</a>
      <ul>
        <li>
          <ul>
            <li><a href="#cache-aside">Cache Aside：</a></li>
            <li><a href="#readwrite-through">Read/Write Through：</a></li>
            <li><a href="#write-back">write back</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
</div>
 


<script type="text/javascript" src="/js/toc.js" defer></script>




        

    </section>
    <section class="func">
        <div id="func-top" class="to-top">
            <a href="#top" target="_self">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 28 28" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    class="lucide lucide-arrow-big-up-dash">
                    <path d="M9 19h6" />
                    <path d="M9 15v-3H5l7-7 7 7h-4v3H9z" />
                </svg>
            </a>
        </div>

    </section>
</aside>
    <div class="content-container">
      <nav class="nav-container">
    <div class="nav-title">
        <a href="/" class="home-link" target="_blank">XUN</a>
    </div>
    <button type="button" class="drop-menu-button">
        <span class="menu-bar"></span>
        <span class="menu-bar"></span>
        <span class="menu-bar"></span>
    </button>
    <ul class="nav-menu-items"><li class="menu-item">
            <a href="/" target="_self">HOME</a>
        </li><li class="menu-item">
            <a href="/archive/" target="_self">ARCHIVE</a>
        </li><li class="menu-item">
            <a href="/notes/" target="_self">NOTES</a>
        </li><li class="menu-item">
            <a href="/about/" target="_self">ABOUT</a>
        </li>
    </ul>
 

</nav>
      <main class="content">
        <div class="page"><article class="post-block">
    <header class="post-header">
        <h1>[八股汇总] redis</h1>
        <div class="post-time">Jun 24 2018</div>
    </header>

    
    <div class="post-content"><p>一些基础概念。</p>
<h2 id="性能--performance">性能 ｜ performance <a href="#%e6%80%a7%e8%83%bd--performance" style="border:none;"></a></h2><p>是基于内存的数据库（in-memory data store as a database）。读写快。</p>
<p>适用场景：缓存（cache）、消息队列（streaming engine）、分布式锁（message broker）。</p>
<p>对数据的操作是原子性（atomic）。单线程执行命令，不存在并发竞争（Concurrent competition）。</p>
<h2 id="和-memcached-比较">和 Memcached 比较 <a href="#%e5%92%8c-memcached-%e6%af%94%e8%be%83" style="border:none;"></a></h2><p>same：</p>
<ul>
<li>基于内存 in-memory</li>
<li>有过期策略 Expiration Policies</li>
<li>性能高 high performance</li>
</ul>
<p>diff:</p>
<ul>
<li>Memcached的type只有key-value</li>
<li>redis支持数据持久化 ｜ data persistence</li>
<li>redis有原生集群模式 ｜ native cluster mode</li>
<li>支持发布订阅、事务功能。｜ sub/pub, transaction</li>
</ul>
<h2 id="为什么作为mysql缓存">为什么作为mysql缓存： <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%9c%e4%b8%bamysql%e7%bc%93%e5%ad%98" style="border:none;"></a></h2><p>高性能 高并发 High performance Concurrency</p>
<p>QPS 是mysql的10倍</p>
<h2 id="数据类型及数据结构">数据类型及数据结构 <a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%8f%8a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" style="border:none;"></a></h2><p>数据类型和数据结构是不同的东西！</p>
<h3 id="数据类型--type">数据类型 ｜ TYPE <a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b--type" style="border:none;"></a></h3><ul>
<li>
<p>基础类型：<br>
包括字符串（ String ） ，哈希（ Hash ），列表（ List ），集合（ Set ）、有序集合（ Zset ）五种</p>
<ul>
<li>string：缓存对象、常规计数、分布式锁、共享 session 信息</li>
<li>list：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）</li>
<li>hash：缓存对象、购物车等</li>
<li>set：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等</li>
<li>zset：排序场景，比如排行榜、电话和姓名排序等</li>
</ul>
</li>
<li>
<p>新增类型<br>
BitMap（2.2 版+）、HyperLogLog（2.8 版+）、GEO（3.2 版+）、Stream（5.0 版+）</p>
<ul>
<li>bitmap：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等</li>
<li>HyperLogLog：海量数据基数统计的场景，比如百万级网页 UV 计数等</li>
<li>geo：存储地理位置信息的场景，比如滴滴叫车</li>
<li>stream：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据</li>
</ul>
</li>
</ul>
<h3 id="数据结构--structure">数据结构 ｜ STRUCTURE： <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84--structure" style="border:none;"></a></h3><p>SDS，double linklist → quicklist，ziplist → listpack，hashtable，int set，skiplist<br>
（此处待补图）</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>SDS：&lt;c的str结构&gt; → &lt;redis的改进&gt;</p>
<ul>
<li>以 <code>/0</code> 结尾，所以内容有限制 → 可以存文本&amp;二进制</li>
<li>顺序存，所以len(n)要O(n) → 有单独存len的字段</li>
<li>可能缓存溢出 → 自动扩容 安全</li>
<li>数据结构：| len | alloc | flags | buf[] |
<ul>
<li>len：存长度代替<code>/0</code>，判断结束</li>
<li>alloc：分配内存长度，和len结合可自动扩容</li>
<li>flags：记录类型，节省内存</li>
<li>buf[]: data<br>
同时有优化对齐，按实际占用内存进行对齐</li>
</ul>
</li>
</ul>
</li>
<li>
<p>linklist：（c没有的链表）<br>
listnode 双向链表 + list结构</p>
<!-- raw HTML omitted -->
<p>缺点：list的head开销大，每个节点内存不连续浪费内。<br>
改进 👇 ziplist</p>
</li>
<li>
<p>ziplist：占用连续内存<br>
数据结构：<br>
| zlbytes | zltail | zllen | ……………………………………… | 结束点 |</p>
<p>总bytes  offset           | prelen | typelen | data |</p>
<p>prelen &amp; typelen : 动态分配内存<br>
data：可以是int 也可以是string</p>
<p>缺点：因为存了pre的len，所以插入一个就要全部重新分配内存，适合数据量少的。<br>
改进 👇 listpack</p>
</li>
<li>
<p>hashtable<br>
O(1) 但冲突 → 链式hash → 一条链上data多了会O(n) → rehash<br>
rehash: redis中有一个结构体内有两个hash表<br>
负载因子触发rehash → 给backup分配更大内存+转移数据 →<br>
copy时间过长 → 渐进式rehash：rehash时两个表都写入<br>
负载因子 = 已存数量 / 表大小</p>
</li>
<li>
<p>int set<br>
是set的底层之一<br>
有连续内存空间<br>
encoding类型有三种：int8 int16 int32<br>
如果新数更大，则触发升级，之前的全生 | 不支持降级<br>
升级时不分配新space，在原数组扩展：节省内存</p>
</li>
<li>
<p>skiplist<br>
支持O(logN) 查找<br>
只有zset用它。zset用两个</p>
<ul>
<li>skiplist ：范围查询</li>
<li>hash： O(1)获取</li>
</ul>
<!-- raw HTML omitted -->
<p>规则：<br>
① 从最高level开始找，比权重<br>
② 权重大了往前，小了往后<br>
③ 当前level无，降一层level</p>
<p>层数设置：<br>
相邻两层2：1</p>
<p>创建node时在0-1中随机生成数x: while x &lt;0.25: level += 1</p>
</li>
<li>
<p>quicklist</p>
<p>双向链表 + 压缩列表</p>
<!-- raw HTML omitted -->
<p>add node时会check该ziplist能否容纳，不能就新建quicklistNode</p>
<p>通过控制每个node的大小or个数，规避连锁更新问题</p>
</li>
<li>
<p>liskpack</p>
<p>| totalbyte | len | ………………………………… | end |<br>
| encoding | data | len |</p>
<p>不记pre长度，只记当前len</p>
</li>
</ul>
<h3 id="数据类型和数据结构的关系">数据类型和数据结构的关系 <a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%92%8c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9a%84%e5%85%b3%e7%b3%bb" style="border:none;"></a></h3><p>string : SDS<br>
list: 双向链表 + 压缩列表 （content &lt; 512 &amp; value &lt; 64b）⇒  quicklist<br>
hash: 哈希表 + ziplist （content &lt; 512 &amp; value &lt; 64b）⇒  listpack<br>
set：哈希表 + 整数set （e:int &amp; count &lt; 512）<br>
zset: skiplist + hash<br>
ziplist（content &lt; 512 &amp; value &lt; 64b） ⇒ listpack</p>
<h2 id="redis-是单线程吗">redis 是单线程吗 <a href="#redis-%e6%98%af%e5%8d%95%e7%ba%bf%e7%a8%8b%e5%90%97" style="border:none;"></a></h2><p>主流程是单线程：接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端</p>
<p>redis程序不是单线程。关闭文件、AOF 刷盘、释放内存有单独线程。</p>
<p>free memory</p>
<p>因为耗时。</p>
<p>6.0之后引入多线程：</p>
<p>随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。所以对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理。</p>
<p>默认情况下 I/O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求。</p>
<h2 id="持久化">持久化 <a href="#%e6%8c%81%e4%b9%85%e5%8c%96" style="border:none;"></a></h2><p>AOF + RDB or 混合</p>
<p>RDB：加载恢复数据快，但是易丢。<br>
AOF：恢复时丢的数据少，但是体积大会慢。<br>
选择：当丢数据也可以时用RDB，否则选AOF<br>
应用：一般主从+读写分离时，master的持久化要关掉，slave开启AOF，关闭RDB，并记录备份的时间点。</p>
<h3 id="aof-日志过大会触发什么机制">AOF 日志过大，会触发什么机制？ <a href="#aof-%e6%97%a5%e5%bf%97%e8%bf%87%e5%a4%a7%e4%bc%9a%e8%a7%a6%e5%8f%91%e4%bb%80%e4%b9%88%e6%9c%ba%e5%88%b6" style="border:none;"></a></h3><p>当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<h3 id="rdb实现">RDB实现： <a href="#rdb%e5%ae%9e%e7%8e%b0" style="border:none;"></a></h3><p>手动两种：save和bgsave</p>
<p>普通save的流程：<br>
①按save<br>
②redis的主线程就阻塞<br>
③生成RDB文件</p>
<p>和bgsave区别是，在主线程阻塞后，bgsave就fork()一个子进程来进行持久化，生成RDB文件，完成之后会给主线程一个通知。#bgsave只有在fork()子进程时短暂阻塞。</p>
<p><strong>save 会阻塞主线程；bgsave 不阻塞</strong></p>
<p>自动三种：</p>
<ul>
<li>命令设置save m n m时间内如有n个键变化则rdb</li>
<li>flushall清空全部时自动备份</li>
<li>主从同步触发。当从全量复制时，主bgsave，并将RBD文件发给从</li>
</ul>
<h2 id="主从-哨兵-集群">主从 哨兵 集群 <a href="#%e4%b8%bb%e4%bb%8e-%e5%93%a8%e5%85%b5-%e9%9b%86%e7%be%a4" style="border:none;"></a></h2><h3 id="主从-master-slaver">主从 master-slaver <a href="#%e4%b8%bb%e4%bb%8e-master-slaver" style="border:none;"></a></h3><p>异步。master操作完就返回，不等slave，不强一致。</p>
<p>读所有server；写只master，master同步给slave</p>
<p>缺点：有单点问题。解决 👇</p>
<h3 id="哨兵-sentinel">哨兵 sentinel： <a href="#%e5%93%a8%e5%85%b5-sentinel" style="border:none;"></a></h3><p>sentinel ping每一个server，监控主从服务器，并且提供主从节点故障转移的功能</p>
<p>数据量大到一台存不下时，解决👇</p>
<h3 id="集群-cluster">集群 cluster： <a href="#%e9%9b%86%e7%be%a4-cluster" style="border:none;"></a></h3><p>data和node之间的映射：hash slot</p>
<p>crc16(key) % 16384 取模，结果代表一个哈希槽</p>
<p>映射到node节点：可均分可手动</p>
<h2 id="过期删除和内存淘汰">过期删除和内存淘汰 <a href="#%e8%bf%87%e6%9c%9f%e5%88%a0%e9%99%a4%e5%92%8c%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0" style="border:none;"></a></h2><h3 id="expire-policy">Expire policy <a href="#expire-policy" style="border:none;"></a></h3><p>惰性 + 定期 ，删除的对象是已过期的 key。</p>
<p>惰性 Lazy deletion:</p>
<p>有请求才检查</p>
<p>tradeoff：对性能好，对内存不好</p>
<p>定期 periodic deletion</p>
<p>隔一段时间随机抽一批检查，设阈值，如果过期量高，循环抽取</p>
<p>tradeoff：省内存。执行频率难把握</p>
<h3 id="内存淘汰">内存淘汰 <a href="#%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0" style="border:none;"></a></h3><p>解决内存过大的问题，内存满了就触发</p>
<!-- raw HTML omitted -->
<h3 id="持久化时对过期键会如何处理">持久化时，对过期键会如何处理？ <a href="#%e6%8c%81%e4%b9%85%e5%8c%96%e6%97%b6%e5%af%b9%e8%bf%87%e6%9c%9f%e9%94%ae%e4%bc%9a%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86" style="border:none;"></a></h3><p>RDB：</p>
<ul>
<li>
<p>文件生成阶段</p>
<p>不影响。会对 key 进行过期检查，过期的键「不会」被保存到新的 RDB 文件中。</p>
</li>
<li>
<p>加载阶段</p>
<ul>
<li>主服务器: 不影响。载入时，会检查键，过期键「不会」被载入到数据库中</li>
<li>从服务器：不影响。载入时不检查全载入，但主从服务器在进行数据同步时，从服务器的数据会被清空。</li>
</ul>
</li>
</ul>
<p>AOF：</p>
<ul>
<li>
<p>写入阶段</p>
<p>影响。如果写入时过期键还没删除，就保留，过期键删除后，追加一条DEL 命令来显式地删除该键值</p>
</li>
<li>
<p>重写阶段</p>
<p>不影响。重写时，会检查键值，已过期的不写入。</p>
</li>
</ul>
<h3 id="主从模式中对过期键会如何处理">主从模式中，对过期键会如何处理 <a href="#%e4%b8%bb%e4%bb%8e%e6%a8%a1%e5%bc%8f%e4%b8%ad%e5%af%b9%e8%bf%87%e6%9c%9f%e9%94%ae%e4%bc%9a%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86" style="border:none;"></a></h3><p>从库不会进行过期扫描，从库对过期的处理是被动的</p>
<p>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key</p>
<h2 id="缓存雪崩热点失效缓存穿透">缓存雪崩、热点失效、缓存穿透 <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9%e7%83%ad%e7%82%b9%e5%a4%b1%e6%95%88%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" style="border:none;"></a></h2><h3 id="缓存穿透--cache-penetration">缓存穿透 ｜ cache penetration <a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f--cache-penetration" style="border:none;"></a></h3><p>程序要访问的缓存key不在缓存key的取值范围里。</p>
<p>原因：误操作 &amp; 黑客</p>
<p>方案：</p>
<ul>
<li>非法请求的限制</li>
<li>设置空值或者默认值</li>
<li>使用布隆过滤器</li>
</ul>
<h3 id="热点失效--hotspot-invalid">热点失效 ｜ hotspot invalid <a href="#%e7%83%ad%e7%82%b9%e5%a4%b1%e6%95%88--hotspot-invalid" style="border:none;"></a></h3><p>缓存的key还是存在的，只是这个热点key的数据失效了。</p>
<p>方案：</p>
<ul>
<li>互斥锁<br>
要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>热点数据单独设置<br>
要么不设过期时间，要么过期前提前通知处理</li>
</ul>
<h3 id="缓存雪崩--cache-avalanche">缓存雪崩 ｜ cache avalanche <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9--cache-avalanche" style="border:none;"></a></h3><p>大量缓存都失效了，像雪崩一样</p>
<p>方案：</p>
<ul>
<li>将缓存失效时间随机打散</li>
<li>设置缓存不过期</li>
</ul>
<h2 id="缓存更新策略">缓存更新策略 <a href="#%e7%bc%93%e5%ad%98%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5" style="border:none;"></a></h2><p>通常有三种：</p>
<h4 id="cache-aside">Cache Aside： <a href="#cache-aside" style="border:none;"></a></h4><p>适合读多写少。写多影响缓存命中率。</p>
<p>直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」</p>
<ul>
<li>写：先更db再删cache</li>
<li>读：读到了，直接返回；没读到，读db，再写回cache</li>
</ul>
<h4 id="readwrite-through">Read/Write Through： <a href="#readwrite-through" style="border:none;"></a></h4><p>应用程序只和缓存交互，不和数据库交互。缓存和数据库交互。<br>
适合本地缓存</p>
<ul>
<li>
<p>Read Through：<br>
cache有直接返回，没有cache问db，写入cache，再返回</p>
</li>
<li>
<p>Write Through：</p>
<p>写时先查cache，如果在，更新cache，cache更新db；如果不在，直接更db。</p>
</li>
</ul>
<h4 id="write-back">write back <a href="#write-back" style="border:none;"></a></h4><p>只更新缓存，同时将缓存数据设置为脏。然后立马返回，不会更新数据库。批量异步更新db<br>
适用计算机体系结构，CPU OS；写多时<br>
不强一致，数据可能丢失。</p></div>

    <div class="post-meta meta">
        

        <span class="tags-box">
            <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512" fill="currentColor"
                class="fas-tags">
                <path
                    d="M345 39.1L472.8 168.4c52.4 53 52.4 138.2 0 191.2L360.8 472.9c-9.3 9.4-24.5 9.5-33.9 .2s-9.5-24.5-.2-33.9L438.6 325.9c33.9-34.3 33.9-89.4 0-123.7L310.9 72.9c-9.3-9.4-9.2-24.6 .2-33.9s24.6-9.2 33.9 .2zM0 229.5V80C0 53.5 21.5 32 48 32H197.5c17 0 33.3 6.7 45.3 18.7l168 168c25 25 25 65.5 0 90.5L277.3 442.7c-25 25-65.5 25-90.5 0l-168-168C6.7 262.7 0 246.5 0 229.5zM144 144a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z" />
            </svg>
            
            
            <a class="tag-link" href="/%20/tags/redis">redis</a>
            
            ,&nbsp;
            <a class="tag-link" href="/%20/tags/%E5%85%AB%E8%82%A1">八股</a>
            
        </span>
        
    </div>

    <div class="post-paginator">
        
        
        <span class="pag-prev">
        
            
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"
                class="lucide lucide-arrow-left-from-line">
                <path d="M3 19V5" />
                <path d="m13 6-6 6 6 6" />
                <path d="M7 12h14" />
            </svg>
            </svg>
            <a href="https://cenjianxun.github.io/posts/%E5%85%AB%E8%82%A1%E6%B1%87%E6%80%BB-%E6%95%B0%E6%8D%AE%E5%BA%93/" class="jump-post">[八股汇总] 数据库</a>
        
        </span>
  
        <span class="pag-next">
            
            
            <a href="https://cenjianxun.github.io/posts/%E5%BD%92%E6%A1%A3%E6%89%8B%E5%86%8C-shell%E5%91%BD%E4%BB%A4/" class="jump-post">[归档手册] shell命令</a>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"
                class="lucide lucide-arrow-right-to-line">
                <path d="M17 12H3" />
                <path d="m11 18 6-6-6-6" />
                <path d="M21 5v14" />
            </svg>
            
        </span>
        
    </div>

    

</article>


    </div>
      </main>
      <footer class="footer">
    <p class="copyright"> © 2018 - 2023 &nbsp; XUN
    </p>
</footer>


    </div>
  </div>
</body>
</html>